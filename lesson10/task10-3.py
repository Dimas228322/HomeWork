#3. Реализовать программу работы с органическими клетками, состоящими из ячеек.
#Техническое задание:

#Создать класс «Клетка». В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
#Перегрузить арифметические операторы: сложение ('add()'), вычитание ('sub()'), умножение ('mul()'), деление ('floordiv').
#Вспомнить/посмотреть какие аргументы у операторов и что они возвращают.
#Эти методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение, и деление клеток, соответственно.
#Сложение. Число ячеек общей клетки равняться сумме ячеек исходных двух клеток.
#Вычитание. Число ячеек общей клетки равняться разности кол-ва ячеек исходных двух клеток.
#Операцию необходимо выполнять, только если разность количества ячеек двух клеток больше нуля, иначе использовать исключение - посмотрите какой тип исключения подойдет лучше всего.
#Умножение. Число ячеек общей клетки равняться произведению кол-ва ячеек исходных двух клеток.
#Деление. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
#Реализовать метод 'make_order()', принимающий количество ячеек в ряду. Этот метод позволяет организовать ячейки по рядам.
#Метод должен возвращать строку вида '**\n\n***...', где количество ячеек между '\n' равно переданному аргументу.
#Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся. Возвращаемое значение предназначено для последующей передачи в функцию print,
#не используйте лишних слешей в строке.
#Например, количество ячеек клетки равняется 12, а количество ячеек в ряду — 5. В этом случае метод 'make_order()' вернёт строку: "*****\n*****\n**".
#Или, количество ячеек клетки — 15, а количество ячеек в ряду равняется 5. Тогда метод 'make_order()' вернёт строку: '*****\n*****\n*****'.
#Создать не менее пяти-семи экземпляров.
#Выполнить все арифметические операторы. Подтвердить тип полученного после операций объекта.
#Исходные клетки и результаты операций показать с помощью make_order
class Kletka:
    def __init__(self, numbers):
        self.numbers = numbers
    # +++
    def __add__(self, other):
            return Kletka(self.numbers + other.numbers)
    # ----
    def __sub__(self, other):
        if isinstance(other, Kletka) and self.numbers > other.numbers:
            return Kletka(self.numbers - other.numbers)
        raise ValueError(f"Ошибка вычитания")
    # ***
    def __mul__(self, other):
        if isinstance(other, Kletka):
            return Kletka(self.numbers * other.numbers)
    #////
    def __floordiv__(self, other):
        if isinstance(other, Kletka):
            return Kletka(self.numbers // other.numbers)

    def make_order(self, row):
        n1 = self.numbers // row
        n2 = self.numbers % row
        return ("*" * row + "\n") * n1 + "*" * n2 + "\n"


k = Kletka(12)
k2 = Kletka(6)
k3 = Kletka(7)
k4 = Kletka(8)
k5 = Kletka(9)
print(k.make_order(5))
plus = k + k2
print(type(plus))
#minus1 = k2 - k
minus = k - k2
ymnojit = k * k2
delenie = k // k2
print (plus.make_order(5))
print (minus.make_order(5))
print (ymnojit.make_order(5))
print (delenie.make_order(5))


