#2. Реализовать проект расчёта суммарного расхода ткани на производство одежды.
#Техническое задание:

#Основная сущность (класс) этого проекта — одежда, которая может иметь определённое название/имя (атрибут).
#К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры:
#размер (для пальто) и рост (для костюма). Это целые числа, например V и H, соответственно. Имена атрибутов можете сделать другими.
#Создать метод расчета ткани для каждого класса: пальто, костюм по формуле: для пальто '(V/6.5 + 0.5)', для костюма '(2*H + 0.3)'.
#Выполнить общий подсчёт расхода ткани для всех созданных экземпляров, отдельно для пальто, отдельно для костюма. Алгоритм должен работать для любого кол-ва экземпляров.
#Общий расход ткани на все экземпляры - это тоже данные. Где их логично хранить?
#Не принципиально будет ли накапливаться общий расход ткани определенным методом или будет скрыт внутри других методов/конструктора.
#Проверить на практике полученные на этом уроке знания. Использовать абстрактный класс для «одежды». Подумайте что должно быть абстрактным методом в классе «одежда».
#Вспомните что должно быть в коде метода, когда он еще не наполнен никакой логикой.
#Используйте наследование. Переопределите абстрактные методы в классах-наследниках.
#Проверить работу декоратора '@property'.
#Не допускайте дублирования кода или спагетти-кода (кода с многочисленными проверками условий).
#Тщательно продумайте что должно быть данными (атрибутами), а что методами.
#Создать не менее 3 экземпляров классов с различными данными.
#Провести расчет ткани для каждого - вывести на экран
#Продемонстрировать накопительный счетчик общего расхода ткани по каждому классу.
from abc import ABC, abstractmethod
class MyAbstractClass(ABC):
    @abstractmethod
    def add_cloth(self):
        raise NotImplementedError

    @abstractmethod
    def formula(self):
        raise NotImplementedError


class Cloth(MyAbstractClass):
    def __init__(self,name):
        self.name = name

class Palto(Cloth):
    NeedTkan = 0
    def __init__(self, size):
        super().__init__('Пальто')
        self.size = size

    @property
    def formula(self):
        return self.size/6.5 + 0.5

    @property
    def add_cloth(self):
        Palto.NeedTkan += self.formula


class Costum(Cloth):
    NeedTkan = 0
    def __init__(self, size):
        super().__init__('Костюм')
        self.size = size

    @property
    def formula(self):
        return 2 * self.size + 0.3

    @property
    def add_cloth(self):
        Costum.NeedTkan += self.formula


p1 = Palto(22)
p2 = Palto(14)
p3 = Palto(28)
p1.add_cloth
p2.add_cloth
p3.add_cloth
print(p1.formula)
print(p2.formula)
print(p3.formula)
print(Palto.NeedTkan)

c1 = Costum(22)
c2 = Costum(12)
c3 = Costum (11)
c1.add_cloth
c2.add_cloth
c3.add_cloth
print(c1.formula)
print(c2.formula)
print(c3.formula)
print(Costum.NeedTkan)