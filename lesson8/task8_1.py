#1. Написать функцию 'email_parse(<email_address>)',
#которая при помощи регулярного выражения извлекает имя пользователя и почтовый домен из email адреса и возвращает их в виде словаря.
#Функция:
#принимает параметр: строка email, при необходимости и другие параметры
#извлекает имя пользователя - то, что до знака @ и домен - то, что после знака @
#возвращает словарь вида {'username': <имя_пользователя>, 'domain': <домен>}
#Если адрес не валиден, выбросить исключение 'ValueError'. Можно с сообщением вида «wrong email: <email_address>»

#Шаблон имени пользователя: латинские буквы, цифры и символы: '._+-
#Шаблон домена: латинские буквы, цифры и символы .-
#В домене обязательно должна быть хотя бы одна точка
#Не использовать методы строки для извлечения информации из email - только регулярные выражения
#email полностью парсится за «один проход». Используйте группы.
#Проверьте работоспособность функции на прилагаемых тестовых email (файл task_8_1_test_email.txt).
#Попытайтесь добиться, чтобы для всех примеров ваша программа работала правильно. Допускаются 2-3 рассогласования.
#Чтобы проверить работоспособность функции на разных данных, вам придется «ловить» исключение в основной программе и выводить сообщение.
import  re
def email_parse (email_address):
    rdate = re.compile('(?P<user>\w+[\.\+\_|\-]\w+)@(?P<domain>[\w]+\.[a-z]{1,6})')
    try:
        s = rdate.match(email_address)
        return s.groupdict()
    except AttributeError:
        #raise ValueError ('wrong email:',email_address) Так и не дошло что с этим выкидыванием делать
        return 'wrong email:', email_address
print(email_parse('user1-name@domenname.ru'))
print(email_parse('user1+name@domenname.ru'))
print(email_parse('user1.name@domenname.ru'))
print(email_parse('user1--name@domenname.ru'))






